#手把手教你做λ（一）关于λ表达式的一切

(前λ讲堂的学员可以跳过此节)

函数语言追根溯源的话，都是来自于 Alonzo Church 和他的学生 Stephen Kleene 在 1932 年的一篇论文引入的 λ-Calculus (λ演算) 的概念。1936 年 Alan Turing 发表论文引入了 Turing Machine (图灵机) 的概念，奠定了他当代计算机科学之父的地位。与此同时，他也成为 Church 的学生，在普林斯顿攻读博士学位。后来 Kleene 证明了λ演算、图灵机和早先 Kurt Gödel 引入的 general recursion (递归) 函数是等价的，并提出了一个伟大的命题，也就是后来人们说的 Church-Turing Thesis (丘齐图灵命题)：任何可计算的东西都能够被这三种方式表达。

当然，可计算 (computable) 并不是一个有着精确定义的概念，这也是为什么丘齐图灵命题是一个无法被证明的 hypothesis (假说)。实际上，Church-Turing Thesis 往往被看作是对“什么是可计算的”一个定义。这个命题的优美之处，还在于它成功地在具象的机器和抽象的代数之间划了一个等号。前者着重执行指令，后者着重于对表达式求值。这也是的命令式语言 (Imperative Language)，和函数式语言 (Functional Language) 的区别。

在一个只学习过命令式语言的程序员看来，Haskell 这类的函数语言实属异类。看似没有清晰的运行流程和分枝结构，既不实用又让人难以理解。其实作为 Haskell 的核心，λ表达式是异常简洁的。下面是关于λ表达式 (λ Expression)，也叫λ项 (λ Term)，的定义：

1. 变元是λ项，通常用小写字母写出来，比如 x,y,z 等; 
2. 如果 M 是λ项，那么 λx.M 也是；
3. 如果 M 和 N 都是λ项，那么 M N 也是。

变元 (variable) 形态的λ项很简单，就是 x 或者 y 或者 z 或者什么别的，我们通常用单个小写字母，有
时候也加上数字脚标，比如 x0, x1, x2 等，以示区分。

抽象 (abstraction) 形态的λ项，写出来就是先用λ这个符号本身作开头，后面跟一个变元，然后一个小点，然后跟一个任意的λ项。例如 λx.x 或 λx.y 或 λx.x x 等。

应用 (application) 形态的λ项，就是两个λ项写在一起，中间仅留一个空格做分隔。例如 f x 或者 x x。 写在前面的λ项通常叫函数(function)，后面的叫参数(argument)。比如在 x x 这个表达式里，就是把 x 这个函数作用于(apply to)它自己。 

在实际书写抽象和应用两种λ项时，如果没有一定的标识，往往会产生歧义。所以通常是用括号来把一个λ项和它前后的符号区分开，比如 (λx.x) y 这个表达式，就是说函数 λx.x 作用在参数 y 上。
我们通常不认为括号本身是λ项的一部分，使用它们纯粹是为了书写。

括号的使用有时候也可以略去。约定俗成的习惯是在表达抽象时，小点后面整个式子（除非是遇到反括号）
都是与小点前面的变元对应的λ项。比如 λx.(λy.(x y)) 就可以简写为 λx.λy.x y；在表达应用时则向左结
合，比如 f x y 应该被理解为 (f x) y 而不是 f (x y)。

#习题

以下哪些是正确的λ项？

1. a b c d e f 
2. (g h) (i j) 
3. λx.(x+1) 
4. λx.f (λy.f y) 
5. λ(x y).y 
6. λ(λx.x).y 
7. (λf.f x y) (λx.λy.x) 
8. λx.y.x 
9. f g λx.y z
