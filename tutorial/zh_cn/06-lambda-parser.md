#手把手教你做λ（六）如何正确识别λ表达式 

在上一节，我们归纳了基础的语法识别器 `char` （识别单个字符）和 `nil`（识别空字串），还有识别器的两种组合方式 `&&&` （序列组合）和 `|||` （分支组合），以及一个灵活转换识别器类型的操作 `mapP`:

      mapP :: (a -> b) -> ReadS a -> ReadS b

在这个基础上，我们还定义了 `many` 和 `many1` ，并且实现了多字符的变元识别器 `variable`。现在，我们可以着手写一个λ项的识别器了。回顾一下λ项的语法和数据结构：

      <term>  ::=   <var> | "λ" <var> "." <term> | 
                    <term> " " <term>

      data Term = Var Var | Lam Var Term | App Term Term 

因为 Haskell 本身就支持定义之间相互引用，所以我们把语法和数据结果对应起来就得到如下的程序：

      term :: ReadS Term
      term = var <|> lam <|> app
      lam  = mapP f (lbd &&& variable &&& sym '.' &&& term)
           where f (((_,v),_),e) = Lam v e
      app  = mapP f (term &&& space &&& term)
           where f ((f, _), e) = App f e
      lbd   = sym '\\' <|> sym 'λ'
      space = many1 (sym ' ')
      sym c = char (==c)

这里，我们定义了 `sym` 函数来辅助识别给定的字符，其中 `(==c)` 的写法叫“section”，因为 `(==)` 需要两个参数才能返回 `Bool`，给它一个参数 `c`，那么就变成还需要一个参数就返回 `Bool`。所以 `(==c)` 表示的是一个用于判断参数是否等于 `c` 的函数。

以上的定义看似合理，但它并不是正确的程序。首先，上节末的习题（三）提到，分支组合 `|||` 应该返回两个分支的所有可能性，而不是仅选择左边（或右边）的识别器。这是为什么呢？我们不妨看看在 GHCi 中求值的例子：

      > term "a a"
      [(a," a")]

原本 `a a` 应该是表示一个应用项，但是 `term` 函数在对它进行分支匹配时，直接选取了 `var` 分支，忽略掉其它的，造成最终结果不正确，而且还有剩余字串未能识别成功。那么把 `app` 放在 `var` 前面是否就正确了呢？也不是。实际上，语法识别是一个不断试探、不断回溯 (backtracking) 的过程，成功匹配了当前的一个分支，并不意味着之后对剩余的字串就能够匹配成功，否则应该选择另外的分支重试。这时候如果把其它分支完全忽略掉，就会错过正确的识别结果。所以正确的 `|||` 定义应该把两个分支的匹配结果都保留下来：

     f ||| g = \s -> map left (f s) ++ map right (g s)
       where left  (x, s) = (Left  x, s)
             right (y, s) = (Right y, s)

在修改了 `|||` 的定义后，我们会发现 `term "a a"` 依然无法成功识别，在得到头两个匹配结果后，它会进入一个无限循环，最终抛出栈溢出的异常：

     > term "a a"
     [(a," a"),((a a),"")*** Exception: stack overflow

这又是为什么呢？更简单一点，直接对 `term ""` 求值就会引发栈溢出。如果我们试着分析这其中的求值过程，会发现当 `term` 面对空串时，`var` 和 `lam` 都匹配不成功，然后进行 `app` 的匹配，而 `app` 又首先使用 `term` 去匹配空串，这就造成了无限的递归循环，最终引发栈溢出。这是一个经典的问题，也即递归下降 (recursive descent) 类型的语法识别器无法处理“左递归语法”识别空串的情况。

不仅如此，当我们回头检视λ项的语法时，会发现 `app` 的写法还有另一个问题。例如 x y z 到底代表了 (x y) z 还是 x (y z)？在本教程第一节里，我们谈到过，解决歧义的方法是默认是向左结合，需要右结合时则使用括号。这时就需要定义个 `paren` 函数来辅助识别左右括号了：

      paren :: ReadS b -> ReadS b
      paren p = mapP f (sym '(' &&& p &&& sym ')')
        where f ((_, x), _) = x

这里，`paren p` 和识别器 `p` 返回一样的值，但包括识别它左右的括号。引入括号之后右结合就不是问题了，那么在处理多项并列时，如何解决默认左结合的问题呢？这时我们可以把用空格分开的λ表达式当成多项式，用 `many1` 来处理：

      term, term', atom :: ReadS Term
      term  = mapP (f id) (many1 term')
        where f g [x]    = x
              f g (x:xs) = f (App (g x)) xs
      term' = mapP fst (atom &&& (space ||| nil))
      atom  = lam <|> var <|> paren term

在 `term` 的定义中，我们用 `many1 term'` 来识别多个 `Term`, 而其中辅助函数 `f` 则是把 `[Term]` 以左结合的方式转变为 `Term`。而且因为 `many1` 至少返回一个识别值，`f` 无须处理空表的情况。在 `f` 的定义里，它的参数 `g` 是用来实现左结合的函数，而 `App (g x)` 的写法可以理解为：对下一个 `x`，先进行左结合 `(g x)`，然后用 `App` 生成新的结合函数，传递下去让 `f` 处理剩下的 `xs`。

如果我们使用 Prelude 里面给出的 `foldl1` 函数，可以更简洁地定义 `term` 如下：

      term = mapP (foldl1 App) (many1 term')

这里，`term'` 是为了处理λ项之间的空格，而 `atom` 则是代表对单项式的识别，包括 `lam`、`var` 以及放在括号里的 `term`。这时我们发现，无论是 `term` 还是 `atom` 都不再是左递归，也就回避了左递归语法引发的问题。

有了正确的语法识别器，我们不难给出对于 `Term` 的 `Read` 类型类的声明（和对 `Var` 的声明类似，我们忽略掉对优先级的处理）：

      instance Read Term where
        readsPrec _ = term

至此，我们完成了一个λ表达式的识别器，解决了初步的程序输入和输出的问题。

*附注：* 因为 `'λ'` 字符其实是个字母，也就是说 `isAlpha 'λ'` 为 `True`，所以建议程序中还是用 `'\\'` 代替，或者把变元的识别从 `isAlpha` 改为 `\x -> x >= 'a' && x <= 'z'`。

#习题

一、我们定义了 `term'` 来处理空格，但这种方法不是特别全面，比如括号后面的空格，或者符号 `.` 前后的空格，都会造成识别失败。能否有一个更好的处理空格的方式？需要怎样修改程序？

二、尽管我们避免了识别应用形态λ项的歧义，但是在使用λ抽象时，依然会有产生歧义的情况。比如 `term "λx.x x"` 会得到三个结果：

      [((λx.(x x)),""),(((λx.x) x),""),((λx.x)," x")]

前两个都完整地匹配了输入字串，这造成 `read "λx.x x" :: Term` 会得到错误 Exception: Prelude.read: ambiguous parse。假设我们定义λ的作用域是延展到最右边，那么应该如何修改语法，让 `read "λx.x x"` 正确读出唯一的结果 `(λx.(x x))`？

